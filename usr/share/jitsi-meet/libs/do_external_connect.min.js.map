{"version":3,"file":"do_external_connect.min.js","mappings":"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","sources":["webpack://jitsi-meet/./node_modules/@hapi/bourne/lib/index.js","webpack://jitsi-meet/./node_modules/clipboard-copy/index.js","webpack://jitsi-meet/webpack/bootstrap","webpack://jitsi-meet/./react/features/base/util/parseURLParams.ts","webpack://jitsi-meet/./react/features/base/util/helpers.ts","webpack://jitsi-meet/./connection_optimization/do_external_connect.js","webpack://jitsi-meet/./react/features/base/config/getRoomName.js","webpack://jitsi-meet/./react/features/base/util/uri.ts","webpack://jitsi-meet/./react/features/base/util/strings.web.ts"],"sourcesContent":["'use strict';\n\n\nconst internals = {\n    suspectRx: /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*\\:/\n};\n\n\nexports.parse = function (text, ...args) {\n\n    // Normalize arguments\n\n    const firstOptions = typeof args[0] === 'object' && args[0];\n    const reviver = args.length > 1 || !firstOptions ? args[0] : undefined;\n    const options = (args.length > 1 && args[1]) || firstOptions || {};\n\n    // Parse normally, allowing exceptions\n\n    const obj = JSON.parse(text, reviver);\n\n    // options.protoAction: 'error' (default) / 'remove' / 'ignore'\n\n    if (options.protoAction === 'ignore') {\n        return obj;\n    }\n\n    // Ignore null and non-objects\n\n    if (!obj ||\n        typeof obj !== 'object') {\n\n        return obj;\n    }\n\n    // Check original string for potential exploit\n\n    if (!text.match(internals.suspectRx)) {\n        return obj;\n    }\n\n    // Scan result for proto keys\n\n    exports.scan(obj, options);\n\n    return obj;\n};\n\n\nexports.scan = function (obj, options = {}) {\n\n    let next = [obj];\n\n    while (next.length) {\n        const nodes = next;\n        next = [];\n\n        for (const node of nodes) {\n            if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {      // Avoid calling node.hasOwnProperty directly\n                if (options.protoAction !== 'remove') {\n                    throw new SyntaxError('Object contains forbidden prototype property');\n                }\n\n                delete node.__proto__;\n            }\n\n            for (const key in node) {\n                const value = node[key];\n                if (value &&\n                    typeof value === 'object') {\n\n                    next.push(node[key]);\n                }\n            }\n        }\n    }\n};\n\n\nexports.safeParse = function (text, reviver) {\n\n    try {\n        return exports.parse(text, reviver);\n    }\n    catch (ignoreError) {\n        return null;\n    }\n};\n","/*! clipboard-copy. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* global DOMException */\n\nmodule.exports = clipboardCopy\n\nfunction makeError () {\n  return new DOMException('The request is not allowed', 'NotAllowedError')\n}\n\nasync function copyClipboardApi (text) {\n  // Use the Async Clipboard API when available. Requires a secure browsing\n  // context (i.e. HTTPS)\n  if (!navigator.clipboard) {\n    throw makeError()\n  }\n  return navigator.clipboard.writeText(text)\n}\n\nasync function copyExecCommand (text) {\n  // Put the text to copy into a <span>\n  const span = document.createElement('span')\n  span.textContent = text\n\n  // Preserve consecutive spaces and newlines\n  span.style.whiteSpace = 'pre'\n  span.style.webkitUserSelect = 'auto'\n  span.style.userSelect = 'all'\n\n  // Add the <span> to the page\n  document.body.appendChild(span)\n\n  // Make a selection object representing the range of text selected by the user\n  const selection = window.getSelection()\n  const range = window.document.createRange()\n  selection.removeAllRanges()\n  range.selectNode(span)\n  selection.addRange(range)\n\n  // Copy text to the clipboard\n  let success = false\n  try {\n    success = window.document.execCommand('copy')\n  } finally {\n    // Cleanup\n    selection.removeAllRanges()\n    window.document.body.removeChild(span)\n  }\n\n  if (!success) throw makeError()\n}\n\nasync function clipboardCopy (text) {\n  try {\n    await copyClipboardApi(text)\n  } catch (err) {\n    // ...Otherwise, use document.execCommand() fallback\n    try {\n      await copyExecCommand(text)\n    } catch (err2) {\n      throw (err2 || err || makeError())\n    }\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// @ts-ignore\nimport Bourne from '@hapi/bourne';\nimport { reportError } from './helpers';\n/**\n * A list if keys to ignore when parsing.\n *\n * @type {string[]}\n */\nconst blacklist = ['__proto__', 'constructor', 'prototype'];\n/**\n * Parses the query/search or fragment/hash parameters out of a specific URL and\n * returns them as a JS object.\n *\n * @param {URL} url - The URL to parse.\n * @param {boolean} dontParse - If falsy, some transformations (for parsing the\n * value as JSON) will be executed.\n * @param {string} source - If {@code 'search'}, the parameters will parsed out\n * of {@code url.search}; otherwise, out of {@code url.hash}.\n * @returns {Object}\n */\nexport function parseURLParams(url, dontParse = false, source = 'hash') {\n    if (typeof url === 'string') {\n        // eslint-disable-next-line no-param-reassign\n        url = new URL(url);\n    }\n    const paramStr = source === 'search' ? url.search : url.hash;\n    const params = {};\n    const paramParts = (paramStr && paramStr.substr(1).split('&')) || [];\n    // Detect and ignore hash params for hash routers.\n    if (source === 'hash' && paramParts.length === 1) {\n        const firstParam = paramParts[0];\n        if (firstParam.startsWith('/') && firstParam.split('&').length === 1) {\n            return params;\n        }\n    }\n    paramParts.forEach(part => {\n        const param = part.split('=');\n        const key = param[0];\n        if (!key || key.split('.').some(k => blacklist.includes(k))) {\n            return;\n        }\n        let value;\n        try {\n            value = param[1];\n            if (!dontParse) {\n                const decoded = decodeURIComponent(value).replace(/\\\\&/, '&');\n                value = decoded === 'undefined' ? undefined : Bourne.parse(decoded);\n            }\n        }\n        catch (e) {\n            reportError(e, `Failed to parse URL parameter value: ${String(value)}`);\n            return;\n        }\n        params[key] = value;\n    });\n    return params;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport clipboardCopy from 'clipboard-copy';\n/**\n * A helper function that behaves similar to Object.assign, but only reassigns a\n * property in target if it's defined in source.\n *\n * @param {Object} target - The target object to assign the values into.\n * @param {Object} source - The source object.\n * @returns {Object}\n */\nexport function assignIfDefined(target, source) {\n    const to = Object(target);\n    for (const nextKey in source) {\n        if (source.hasOwnProperty(nextKey)) {\n            const value = source[nextKey];\n            if (typeof value !== 'undefined') {\n                to[nextKey] = value;\n            }\n        }\n    }\n    return to;\n}\n/**\n * Tries to copy a given text to the clipboard.\n * Returns true if the action succeeds.\n *\n * @param {string} textToCopy - Text to be copied.\n * @returns {Promise<boolean>}\n */\nexport function copyText(textToCopy) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield clipboardCopy(textToCopy);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    });\n}\n/**\n * Creates a deferred object.\n *\n * @returns {{promise, resolve, reject}}\n */\nexport function createDeferred() {\n    const deferred = {};\n    deferred.promise = new Promise((resolve, reject) => {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n    });\n    return deferred;\n}\nconst MATCH_OPERATOR_REGEXP = /[|\\\\{}()[\\]^$+*?.-]/g;\n/**\n * Escape RegExp special characters.\n *\n * Based on https://github.com/sindresorhus/escape-string-regexp.\n *\n * @param {string} s - The regexp string to escape.\n * @returns {string}\n */\nexport function escapeRegexp(s) {\n    if (typeof s !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    return s.replace(MATCH_OPERATOR_REGEXP, '\\\\$&');\n}\n/**\n * Returns the base URL of the app.\n *\n * @param {Object} w - Window object to use instead of the built in one.\n * @returns {string}\n */\nexport function getBaseUrl(w = window) {\n    const doc = w.document;\n    const base = doc.querySelector('base');\n    if (base && base.href) {\n        return base.href;\n    }\n    const { protocol, host } = w.location;\n    return `${protocol}//${host}`;\n}\n/**\n * Returns the namespace for all global variables, functions, etc that we need.\n *\n * @returns {Object} The namespace.\n *\n * NOTE: After React-ifying everything this should be the only global.\n */\nexport function getJitsiMeetGlobalNS() {\n    // @ts-ignore\n    if (!window.JitsiMeetJS) {\n        // @ts-ignore\n        window.JitsiMeetJS = {};\n    }\n    // @ts-ignore\n    if (!window.JitsiMeetJS.app) {\n        // @ts-ignore\n        window.JitsiMeetJS.app = {};\n    }\n    // @ts-ignore\n    return window.JitsiMeetJS.app;\n}\n/**\n * Prints the error and reports it to the global error handler.\n *\n * @param {Error} e - The error object.\n * @param {string} msg - A custom message to print in addition to the error.\n * @returns {void}\n */\nexport function reportError(e, msg = '') {\n    console.error(msg, e);\n    window.onerror && window.onerror(msg, undefined, undefined, undefined, e);\n}\n/**\n * Adds alpha to a color css string.\n *\n * @param {string} color - The color string either in rgb... Or #... Format.\n * @param {number} opacity -The opacity(alpha) to apply to the color. Can take a value between 0 and 1, including.\n * @returns {string} - The color with applied alpha.\n */\nexport function setColorAlpha(color, opacity) {\n    if (!color) {\n        return `rgba(0, 0, 0, ${opacity})`;\n    }\n    let b, g, r;\n    try {\n        if (color.startsWith('rgb')) {\n            [r, g, b] = color.split('(')[1].split(')')[0].split(',').map(c => c.trim());\n        }\n        else if (color.startsWith('#')) {\n            if (color.length === 4) {\n                [r, g, b] = parseShorthandColor(color);\n            }\n            else {\n                r = parseInt(color.substring(1, 3), 16);\n                g = parseInt(color.substring(3, 5), 16);\n                b = parseInt(color.substring(5, 7), 16);\n            }\n        }\n        else {\n            return color;\n        }\n        return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n    }\n    catch (_a) {\n        return color;\n    }\n}\n/**\n * Gets the hexa rgb values for a shorthand css color.\n *\n * @param {string} color -\n * @returns {Array<number>} - Array containing parsed r, g, b values of the color.\n */\nfunction parseShorthandColor(color) {\n    let b, g, r;\n    r = color.substring(1, 2);\n    r += r;\n    r = parseInt(r, 16);\n    g = color.substring(2, 3);\n    g += g;\n    g = parseInt(g, 16);\n    b = color.substring(3, 4);\n    b += b;\n    b = parseInt(b, 16);\n    return [r, g, b];\n}\n/**\n * Sorts an object by a sort function, same functionality as array.sort().\n *\n * @param {Object} object - The data object.\n * @param {Function} callback - The sort function.\n * @returns {void}\n */\nexport function objectSort(object, callback) {\n    return Object.entries(object)\n        .sort(([, a], [, b]) => callback(a, b))\n        .reduce((row, [key, value]) => {\n        return Object.assign(Object.assign({}, row), { [key]: value });\n    }, {});\n}\n","/* global config, createConnectionExternally */\n\nimport getRoomName from '../react/features/base/config/getRoomName';\nimport { parseURLParams } from '../react/features/base/util/parseURLParams';\n\n/**\n * Implements external connect using createConnectionExternally function defined\n * in external_connect.js for Jitsi Meet. Parses the room name and JSON Web\n * Token (JWT) from the URL and executes createConnectionExternally.\n *\n * NOTE: If you are using lib-jitsi-meet without Jitsi Meet, you should use this\n * file as reference only because the implementation is Jitsi Meet-specific.\n *\n * NOTE: For optimal results this file should be included right after\n * external_connect.js.\n */\n\nif (typeof createConnectionExternally === 'function') {\n    // URL params have higher priority than config params.\n    // Do not use external connect if websocket is enabled.\n    let url\n        = parseURLParams(window.location, true, 'hash')[\n                'config.externalConnectUrl']\n            || config.websocket ? undefined : config.externalConnectUrl;\n    const isRecorder\n        = parseURLParams(window.location, true, 'hash')['config.iAmRecorder'];\n\n    let roomName;\n\n    if (url && (roomName = getRoomName()) && !isRecorder) {\n        url += `?room=${roomName}`;\n\n        const token = parseURLParams(window.location, true, 'search').jwt;\n\n        if (token) {\n            url += `&token=${token}`;\n        }\n\n        createConnectionExternally(\n            url,\n            connectionInfo => {\n                // Sets that global variable to be used later by connect method\n                // in connection.js.\n                window.XMPPAttachInfo = {\n                    status: 'success',\n                    data: connectionInfo\n                };\n                checkForConnectHandlerAndConnect();\n            },\n            errorCallback);\n    } else {\n        errorCallback();\n    }\n} else {\n    errorCallback();\n}\n\n/**\n * Check if connect from connection.js was executed and executes the handler\n * that is going to finish the connect work.\n *\n * @returns {void}\n */\nfunction checkForConnectHandlerAndConnect() {\n    window.APP\n        && window.APP.connect.status === 'ready'\n        && window.APP.connect.handler();\n}\n\n/**\n * Implements a callback to be invoked if anything goes wrong.\n *\n * @param {Error} error - The specifics of what went wrong.\n * @returns {void}\n */\nfunction errorCallback(error) {\n    // The value of error is undefined if external connect is disabled.\n    error && console.warn(error);\n\n    // Sets that global variable to be used later by connect method in\n    // connection.js.\n    window.XMPPAttachInfo = {\n        status: 'error'\n    };\n    checkForConnectHandlerAndConnect();\n}\n","// @flow\n\nimport { getBackendSafeRoomName } from '../util';\n\n/**\n * Builds and returns the room name.\n *\n * @returns {string}\n */\nexport default function getRoomName(): ?string {\n    const path = window.location.pathname;\n\n    // The last non-directory component of the path (name) is the room.\n    const roomName = path.substring(path.lastIndexOf('/') + 1) || undefined;\n\n    return getBackendSafeRoomName(roomName);\n}\n","import { parseURLParams } from './parseURLParams';\n// eslint-disable-next-line lines-around-comment\n// @ts-ignore\nimport { normalizeNFKC } from './strings';\n/**\n * The app linking scheme.\n * TODO: This should be read from the manifest files later.\n */\nexport const APP_LINK_SCHEME = 'org.jitsi.meet:';\n/**\n * A list of characters to be excluded/removed from the room component/segment\n * of a conference/meeting URI/URL. The list is based on RFC 3986 and the jxmpp\n * library utilized by jicofo.\n */\nconst _ROOM_EXCLUDE_PATTERN = '[\\\\:\\\\?#\\\\[\\\\]@!$&\\'()*+,;=></\"]';\n/**\n * The {@link RegExp} pattern of the authority of a URI.\n *\n * @private\n * @type {string}\n */\nconst _URI_AUTHORITY_PATTERN = '(//[^/?#]+)';\n/**\n * The {@link RegExp} pattern of the path of a URI.\n *\n * @private\n * @type {string}\n */\nconst _URI_PATH_PATTERN = '([^?#]*)';\n/**\n * The {@link RegExp} pattern of the protocol of a URI.\n *\n * FIXME: The URL class exposed by JavaScript will not include the colon in\n * the protocol field. Also in other places (at the time of this writing:\n * the DeepLinkingMobilePage.js) the APP_LINK_SCHEME does not include\n * the double dots, so things are inconsistent.\n *\n * @type {string}\n */\nexport const URI_PROTOCOL_PATTERN = '^([a-z][a-z0-9\\\\.\\\\+-]*:)';\n/**\n * Excludes/removes certain characters from a specific path part which are\n * incompatible with Jitsi Meet on the client and/or server sides. The main\n * use case for this method is to clean up the room name and the tenant.\n *\n * @param {?string} pathPart - The path part to fix.\n * @private\n * @returns {?string}\n */\nfunction _fixPathPart(pathPart) {\n    return pathPart\n        ? pathPart.replace(new RegExp(_ROOM_EXCLUDE_PATTERN, 'g'), '')\n        : pathPart;\n}\n/**\n * Fixes the scheme part of a specific URI (string) so that it contains a\n * well-known scheme such as HTTP(S). For example, the mobile app implements an\n * app-specific URI scheme in addition to Universal Links. The app-specific\n * scheme may precede or replace the well-known scheme. In such a case, dealing\n * with the app-specific scheme only complicates the logic and it is simpler to\n * get rid of it (by translating the app-specific scheme into a well-known\n * scheme).\n *\n * @param {string} uri - The URI (string) to fix the scheme of.\n * @private\n * @returns {string}\n */\nfunction _fixURIStringScheme(uri) {\n    const regex = new RegExp(`${URI_PROTOCOL_PATTERN}+`, 'gi');\n    const match = regex.exec(uri);\n    if (match) {\n        // As an implementation convenience, pick up the last scheme and make\n        // sure that it is a well-known one.\n        let protocol = match[match.length - 1].toLowerCase();\n        if (protocol !== 'http:' && protocol !== 'https:') {\n            protocol = 'https:';\n        }\n        /* eslint-disable no-param-reassign */\n        uri = uri.substring(regex.lastIndex);\n        if (uri.startsWith('//')) {\n            // The specified URL was not a room name only, it contained an\n            // authority.\n            uri = protocol + uri;\n        }\n        /* eslint-enable no-param-reassign */\n    }\n    return uri;\n}\n/**\n * Converts a path to a backend-safe format, by splitting the path '/' processing each part.\n * Properly lowercased and url encoded.\n *\n * @param {string?} path - The path to convert.\n * @returns {string?}\n */\nexport function getBackendSafePath(path) {\n    if (!path) {\n        return path;\n    }\n    return path\n        .split('/')\n        .map(getBackendSafeRoomName)\n        .join('/');\n}\n/**\n * Converts a room name to a backend-safe format. Properly lowercased and url encoded.\n *\n * @param {string?} room - The room name to convert.\n * @returns {string?}\n */\nexport function getBackendSafeRoomName(room) {\n    if (!room) {\n        return room;\n    }\n    /* eslint-disable no-param-reassign */\n    try {\n        // We do not know if we get an already encoded string at this point\n        // as different platforms do it differently, but we need a decoded one\n        // for sure. However since decoding a non-encoded string is a noop, we're safe\n        // doing it here.\n        room = decodeURIComponent(room);\n    }\n    catch (e) {\n        // This can happen though if we get an unencoded string and it contains\n        // some characters that look like an encoded entity, but it's not.\n        // But in this case we're fine goin on...\n    }\n    // Normalize the character set.\n    room = normalizeNFKC(room);\n    // Only decoded and normalized strings can be lowercased properly.\n    room = room === null || room === void 0 ? void 0 : room.toLowerCase();\n    // But we still need to (re)encode it.\n    room = encodeURIComponent(room !== null && room !== void 0 ? room : '');\n    /* eslint-enable no-param-reassign */\n    // Unfortunately we still need to lowercase it, because encoding a string will\n    // add some uppercase characters, but some backend services\n    // expect it to be full lowercase. However lowercasing an encoded string\n    // doesn't change the string value.\n    return room.toLowerCase();\n}\n/**\n * Gets the (Web application) context root defined by a specific location (URI).\n *\n * @param {Object} location - The location (URI) which defines the (Web\n * application) context root.\n * @public\n * @returns {string} - The (Web application) context root defined by the\n * specified {@code location} (URI).\n */\nexport function getLocationContextRoot({ pathname }) {\n    const contextRootEndIndex = pathname.lastIndexOf('/');\n    return (contextRootEndIndex === -1\n        ? '/'\n        : pathname.substring(0, contextRootEndIndex + 1));\n}\n/**\n * Constructs a new {@code Array} with URL parameter {@code String}s out of a\n * specific {@code Object}.\n *\n * @param {Object} obj - The {@code Object} to turn into URL parameter\n * {@code String}s.\n * @returns {Array<string>} The {@code Array} with URL parameter {@code String}s\n * constructed out of the specified {@code obj}.\n */\nfunction _objectToURLParamsArray(obj = {}) {\n    const params = [];\n    for (const key in obj) { // eslint-disable-line guard-for-in\n        try {\n            params.push(`${key}=${encodeURIComponent(JSON.stringify(obj[key]))}`);\n        }\n        catch (e) {\n            console.warn(`Error encoding ${key}: ${e}`);\n        }\n    }\n    return params;\n}\n/**\n * Parses a specific URI string into an object with the well-known properties of\n * the {@link Location} and/or {@link URL} interfaces implemented by Web\n * browsers. The parsing attempts to be in accord with IETF's RFC 3986.\n *\n * @param {string} str - The URI string to parse.\n * @public\n * @returns {{\n *     hash: string,\n *     host: (string|undefined),\n *     hostname: (string|undefined),\n *     pathname: string,\n *     port: (string|undefined),\n *     protocol: (string|undefined),\n *     search: string\n * }}\n */\nexport function parseStandardURIString(str) {\n    /* eslint-disable no-param-reassign */\n    const obj = {\n        toString: _standardURIToString\n    };\n    let regex;\n    let match;\n    // XXX A URI string as defined by RFC 3986 does not contain any whitespace.\n    // Usually, a browser will have already encoded any whitespace. In order to\n    // avoid potential later problems related to whitespace in URI, strip any\n    // whitespace. Anyway, the Jitsi Meet app is not known to utilize unencoded\n    // whitespace so the stripping is deemed safe.\n    str = str.replace(/\\s/g, '');\n    // protocol\n    regex = new RegExp(URI_PROTOCOL_PATTERN, 'gi');\n    match = regex.exec(str);\n    if (match) {\n        obj.protocol = match[1].toLowerCase();\n        str = str.substring(regex.lastIndex);\n    }\n    // authority\n    regex = new RegExp(`^${_URI_AUTHORITY_PATTERN}`, 'gi');\n    match = regex.exec(str);\n    if (match) {\n        let authority = match[1].substring(/* // */ 2);\n        str = str.substring(regex.lastIndex);\n        // userinfo\n        const userinfoEndIndex = authority.indexOf('@');\n        if (userinfoEndIndex !== -1) {\n            authority = authority.substring(userinfoEndIndex + 1);\n        }\n        // @ts-ignore\n        obj.host = authority;\n        // port\n        const portBeginIndex = authority.lastIndexOf(':');\n        if (portBeginIndex !== -1) {\n            obj.port = authority.substring(portBeginIndex + 1);\n            authority = authority.substring(0, portBeginIndex);\n        }\n        // hostname\n        obj.hostname = authority;\n    }\n    // pathname\n    regex = new RegExp(`^${_URI_PATH_PATTERN}`, 'gi');\n    match = regex.exec(str);\n    let pathname;\n    if (match) {\n        pathname = match[1];\n        str = str.substring(regex.lastIndex);\n    }\n    if (pathname) {\n        pathname.startsWith('/') || (pathname = `/${pathname}`);\n    }\n    else {\n        pathname = '/';\n    }\n    obj.pathname = pathname;\n    // query\n    if (str.startsWith('?')) {\n        let hashBeginIndex = str.indexOf('#', 1);\n        if (hashBeginIndex === -1) {\n            hashBeginIndex = str.length;\n        }\n        obj.search = str.substring(0, hashBeginIndex);\n        str = str.substring(hashBeginIndex);\n    }\n    else {\n        obj.search = ''; // Google Chrome\n    }\n    // fragment\n    obj.hash = str.startsWith('#') ? str : '';\n    /* eslint-enable no-param-reassign */\n    return obj;\n}\n/**\n * Parses a specific URI which (supposedly) references a Jitsi Meet resource\n * (location).\n *\n * @param {(string|undefined)} uri - The URI to parse which (supposedly)\n * references a Jitsi Meet resource (location).\n * @public\n * @returns {{\n *     contextRoot: string,\n *     hash: string,\n *     host: string,\n *     hostname: string,\n *     pathname: string,\n *     port: string,\n *     protocol: string,\n *     room: (string|undefined),\n *     search: string\n * }}\n */\nexport function parseURIString(uri) {\n    if (typeof uri !== 'string') {\n        return undefined;\n    }\n    const obj = parseStandardURIString(_fixURIStringScheme(uri));\n    // XXX While the components/segments of pathname are URI encoded, Jitsi Meet\n    // on the client and/or server sides still don't support certain characters.\n    obj.pathname = obj.pathname.split('/').map((pathPart) => _fixPathPart(pathPart))\n        .join('/');\n    // Add the properties that are specific to a Jitsi Meet resource (location)\n    // such as contextRoot, room:\n    // contextRoot\n    // @ts-ignore\n    obj.contextRoot = getLocationContextRoot(obj);\n    // The room (name) is the last component/segment of pathname.\n    const { pathname } = obj;\n    const contextRootEndIndex = pathname.lastIndexOf('/');\n    obj.room = pathname.substring(contextRootEndIndex + 1) || undefined;\n    if (contextRootEndIndex > 1) {\n        // The part of the pathname from the beginning to the room name is the tenant.\n        obj.tenant = pathname.substring(1, contextRootEndIndex);\n    }\n    return obj;\n}\n/**\n * Implements {@code href} and {@code toString} for the {@code Object} returned\n * by {@link #parseStandardURIString}.\n *\n * @param {Object} [thiz] - An {@code Object} returned by\n * {@code #parseStandardURIString} if any; otherwise, it is presumed that the\n * function is invoked on such an instance.\n * @returns {string}\n */\nfunction _standardURIToString(thiz) {\n    // @ts-ignore\n    // eslint-disable-next-line no-invalid-this\n    const { hash, host, pathname, protocol, search } = thiz || this;\n    let str = '';\n    protocol && (str += protocol);\n    // TODO userinfo\n    host && (str += `//${host}`);\n    str += pathname || '/';\n    search && (str += search);\n    hash && (str += hash);\n    return str;\n}\n/**\n * Sometimes we receive strings that we don't know if already percent-encoded, or not, due to the\n * various sources we get URLs or room names. This function encapsulates the decoding in a safe way.\n *\n * @param {string} text - The text to decode.\n * @returns {string}\n */\nexport function safeDecodeURIComponent(text) {\n    try {\n        return decodeURIComponent(text);\n    }\n    catch (e) {\n        // The text wasn't encoded.\n    }\n    return text;\n}\n/**\n * Attempts to return a {@code String} representation of a specific\n * {@code Object} which is supposed to represent a URL. Obviously, if a\n * {@code String} is specified, it is returned. If a {@code URL} is specified,\n * its {@code URL#href} is returned. Additionally, an {@code Object} similar to\n * the one accepted by the constructor of Web's ExternalAPI is supported on both\n * mobile/React Native and Web/React.\n *\n * @param {Object|string} obj - The URL to return a {@code String}\n * representation of.\n * @returns {string} - A {@code String} representation of the specified\n * {@code obj} which is supposed to represent a URL.\n */\nexport function toURLString(obj) {\n    let str;\n    switch (typeof obj) {\n        case 'object':\n            if (obj) {\n                if (obj instanceof URL) {\n                    str = obj.href;\n                }\n                else {\n                    str = urlObjectToString(obj);\n                }\n            }\n            break;\n        case 'string':\n            str = String(obj);\n            break;\n    }\n    return str;\n}\n/**\n * Attempts to return a {@code String} representation of a specific\n * {@code Object} similar to the one accepted by the constructor\n * of Web's ExternalAPI.\n *\n * @param {Object} o - The URL to return a {@code String} representation of.\n * @returns {string} - A {@code String} representation of the specified\n * {@code Object}.\n */\nexport function urlObjectToString(o) {\n    // First normalize the given url. It come as o.url or split into o.serverURL\n    // and o.room.\n    let tmp;\n    if (o.serverURL && o.room) {\n        tmp = new URL(o.room, o.serverURL).toString();\n    }\n    else if (o.room) {\n        tmp = o.room;\n    }\n    else {\n        tmp = o.url || '';\n    }\n    const url = parseStandardURIString(_fixURIStringScheme(tmp));\n    // protocol\n    if (!url.protocol) {\n        let protocol = o.protocol || o.scheme;\n        if (protocol) {\n            // Protocol is supposed to be the scheme and the final ':'. Anyway,\n            // do not make a fuss if the final ':' is not there.\n            protocol.endsWith(':') || (protocol += ':');\n            url.protocol = protocol;\n        }\n    }\n    // authority & pathname\n    let { pathname } = url;\n    if (!url.host) {\n        // Web's ExternalAPI domain\n        //\n        // It may be host/hostname and pathname with the latter denoting the\n        // tenant.\n        const domain = o.domain || o.host || o.hostname;\n        if (domain) {\n            const { host, hostname, pathname: contextRoot, port } = parseStandardURIString(\n            // XXX The value of domain in supposed to be host/hostname\n            // and, optionally, pathname. Make sure it is not taken for\n            // a pathname only.\n            _fixURIStringScheme(`${APP_LINK_SCHEME}//${domain}`));\n            // authority\n            if (host) {\n                url.host = host;\n                url.hostname = hostname;\n                url.port = port;\n            }\n            // pathname\n            pathname === '/' && contextRoot !== '/' && (pathname = contextRoot);\n        }\n    }\n    // pathname\n    // Web's ExternalAPI roomName\n    const room = o.roomName || o.room;\n    if (room\n        && (url.pathname.endsWith('/')\n            || !url.pathname.endsWith(`/${room}`))) {\n        pathname.endsWith('/') || (pathname += '/');\n        pathname += room;\n    }\n    url.pathname = pathname;\n    // query/search\n    // Web's ExternalAPI jwt and lang\n    const { jwt, lang, release } = o;\n    const search = new URLSearchParams(url.search);\n    if (jwt) {\n        search.set('jwt', jwt);\n    }\n    const { defaultLanguage } = o.configOverwrite || {};\n    if (lang || defaultLanguage) {\n        search.set('lang', lang || defaultLanguage);\n    }\n    if (release) {\n        search.set('release', release);\n    }\n    const searchString = search.toString();\n    if (searchString) {\n        url.search = `?${searchString}`;\n    }\n    // fragment/hash\n    let { hash } = url;\n    for (const urlPrefix of ['config', 'interfaceConfig', 'devices', 'userInfo', 'appData']) {\n        const urlParamsArray = _objectToURLParamsArray(o[`${urlPrefix}Overwrite`]\n            || o[urlPrefix]\n            || o[`${urlPrefix}Override`]);\n        if (urlParamsArray.length) {\n            let urlParamsString = `${urlPrefix}.${urlParamsArray.join(`&${urlPrefix}.`)}`;\n            if (hash.length) {\n                urlParamsString = `&${urlParamsString}`;\n            }\n            else {\n                hash = '#';\n            }\n            hash += urlParamsString;\n        }\n    }\n    url.hash = hash;\n    return url.toString() || undefined;\n}\n/**\n * Adds hash params to URL.\n *\n * @param {URL} url - The URL.\n * @param {Object} hashParamsToAdd - A map with the parameters to be set.\n * @returns {URL} - The new URL.\n */\nexport function addHashParamsToURL(url, hashParamsToAdd = {}) {\n    const params = parseURLParams(url);\n    const urlParamsArray = _objectToURLParamsArray(Object.assign(Object.assign({}, params), hashParamsToAdd));\n    if (urlParamsArray.length) {\n        url.hash = `#${urlParamsArray.join('&')}`;\n    }\n    return url;\n}\n/**\n * Returns the decoded URI.\n *\n * @param {string} uri - The URI to decode.\n * @returns {string}\n */\nexport function getDecodedURI(uri) {\n    return decodeURI(uri.replace(/^https?:\\/\\//i, ''));\n}\n/**\n * Adds new param to a url string. Checks whether to use '?' or '&' as a separator (checks for already existing params).\n *\n * @param {string} url - The url to modify.\n * @param {string} name - The param name to add.\n * @param {string} value - The value for the param.\n *\n * @returns {string} - The modified url.\n */\nexport function appendURLParam(url, name, value) {\n    const newUrl = new URL(url);\n    newUrl.searchParams.append(name, value);\n    return newUrl.toString();\n}\n","/**\n * Applies NFKC normalization to the given text.\n *\n * @param {string} text - The text that needs to be normalized.\n * @returns {string} - The normalized text.\n */\nexport function normalizeNFKC(text) {\n    return text.normalize('NFKC');\n}\n/**\n * Replaces accent characters with english alphabet characters.\n * NOTE: Here we use the unorm package because the JSC version in React Native for Android crashes.\n *\n * @param {string} text - The text that needs to be normalized.\n * @returns {string} - The normalized text.\n */\nexport function normalizeAccents(text) {\n    return text.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n}\n"],"names":["internals","exports","parse","text","firstOptions","reviver","undefined","options","obj","JSON","protoAction","match","scan","next","length","nodes","node","Object","prototype","hasOwnProperty","call","SyntaxError","__proto__","key","value","push","safeParse","ignoreError","makeError","DOMException","module","async","navigator","clipboard","writeText","copyClipboardApi","err","span","document","createElement","textContent","style","whiteSpace","webkitUserSelect","userSelect","body","appendChild","selection","window","getSelection","range","createRange","removeAllRanges","selectNode","addRange","success","execCommand","removeChild","copyExecCommand","err2","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","blacklist","url","dontParse","source","URL","paramStr","search","hash","params","paramParts","substr","split","firstParam","startsWith","forEach","part","param","some","k","includes","decoded","decodeURIComponent","replace","e","msg","console","error","onerror","reportError","String","createConnectionExternally","parseURLParams","location","config","websocket","externalConnectUrl","isRecorder","roomName","path","pathname","room","normalize","toLowerCase","encodeURIComponent","getBackendSafeRoomName","substring","lastIndexOf","getRoomName","token","jwt","connectionInfo","XMPPAttachInfo","status","data","checkForConnectHandlerAndConnect","errorCallback","APP","connect","handler","warn"],"sourceRoot":""}